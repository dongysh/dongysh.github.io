<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		01 PHP/PHP基础知识 | 
	 
	小P笔记本
	</title>
	
	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	
  

	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">


	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>

	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
<meta name="generator" content="Hexo 4.2.1"></head>

<body>
	<header id="header">
    <a id="title" href="/" class="logo">小P笔记本</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">ABOUT</a>
		</li>
		
		<li class="menu-item">
			<a href="https://github.com/wujun234/uid-generator-spring-boot-starter" class="menu-item-link" target="_blank">
				UidGenerator
			</a>
		</li>
		<li class="menu-item">
			<a href="https://github.com/wujun234" class="menu-item-link" target="_blank">
				<i class="fa fa-github fa-2x"></i>
			</a>
		</li>
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="text" placeholder="search...">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										01 PHP
									</a>
									
							<ul>
								<li class="file active">
									<a href="/2020/05/23/01%20PHP/PHP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">
										PHP基础知识
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">

	PHP基础知识
</h1>
<div class="article-meta">
	
	<span>dongysh</span>
	<span>2020-05-23 16:48:30</span>
    
		<div id="article-categories">
            
		</div>
    
</div>

<div id="article-content">
	<h2 id="PHP7新特性"><a href="#PHP7新特性" class="headerlink" title="PHP7新特性"></a>PHP7新特性</h2><ol>
<li>新增throwable接口，以前的许多致命错误，现在改成抛出异常。</li>
<li>新增了空接合操作符</li>
<li>新增了结合比较运算符</li>
<li>新增了函数的返回类型声明</li>
<li>新增了标量类型声明</li>
<li>新增了匿名类</li>
<li>新增了常量数组声明</li>
<li>namespace批量导入</li>
<li>新增了抽象语法树</li>
<li>移除了一些老的不在支持的SAPI（服务器端应用编程端口）和扩展</li>
</ol>
<h2 id="PHP7优化原理"><a href="#PHP7优化原理" class="headerlink" title="PHP7优化原理"></a>PHP7优化原理</h2><ol>
<li>变量存储字节减小，减少内存占用，提升变量操作速度</li>
<li>改善数组结构，数组元素和hash映射表被分配在同一块内存里，降低了内存占用、提升了 cpu 缓存命中率</li>
<li>改进了函数的调用机制，通过优化参数传递的环节，减少了一些指令，提高执行效率</li>
</ol>
<h2 id="PHP7优化原理详版"><a href="#PHP7优化原理详版" class="headerlink" title="PHP7优化原理详版"></a>PHP7优化原理详版</h2><ol>
<li>zval使用栈内存，php7直接使用栈内存，好处是少了一次内存分配</li>
<li>zend_string存储hash值，array查询不再需要重复计算hash</li>
<li>hashtable桶内直接存放数据，减少了内存申请次数，顺便也提升了cache命中率和访问速度。因为指针不是连续的是分布在不同的内存页上，如果读取第一个或者第三个桶，它们的数据可能会在两个页上。</li>
<li>zend_parse_parameters改为宏实现，性能提升15%。</li>
<li>新增加4种opcode，call_user_function(),is_int(),is_string(),is_array(),strlen(),defined() 4个函数变为php opcode指令，速度更快。</li>
<li>PHP7 的内核中有一个重要的变化是加入了 AST（Abstract syntax tree）抽象语法树，指代码在计算机内存的一种树状数据结构，树上的每个节点都表示源代码中的一种结构，便于计算机理解和解析。</li>
<li>其他更多性能优化，如基础类型 float ， int ， bool等改成直接进行值拷贝。排序算法改进了。</li>
</ol>
<h2 id="PHP7-zval变化"><a href="#PHP7-zval变化" class="headerlink" title="PHP7 zval变化"></a>PHP7 zval变化</h2><p>答： zval 不再单独从堆上分配内存并且不自己存储引用计数。需要使用 zval 指针的复杂类型（比如字符串、数组和对象）会自己存储引用计数。这样就可以有更少的内存分配操作、更少的间接指针使用以及更少的内存分配。</p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><h4 id="PHP5-中-zval-实现方式存在的主要问题"><a href="#PHP5-中-zval-实现方式存在的主要问题" class="headerlink" title="PHP5 中 zval 实现方式存在的主要问题"></a>PHP5 中 zval 实现方式存在的主要问题</h4><ol>
<li>zval 总是单独从堆中分配内存；</li>
<li>zval 总是存储引用计数和循环回收的信息，即使是整型这种可能并不需要此类信息的数据；</li>
<li>在使用对象或者资源时，直接引用会导致两次计数（原因会在下一部分讲）；</li>
<li>某些间接访问需要一个更好的处理方式。比如现在访问存储在变量中的对象间接使用了四个指针（指针链的长度为四）。这个问题也放到下一部分讨论；</li>
<li>直接计数也就意味着数值只能在 zval 之间共享。如果想在 zval 和 hashtable key 之间共享一个字符串就不行（除非 hashtable key 也是 zval）。 </li>
</ol>
<h4 id="PHP7-zval实现方式的好处"><a href="#PHP7-zval实现方式的好处" class="headerlink" title="PHP7 zval实现方式的好处"></a>PHP7 zval实现方式的好处</h4><ol>
<li><p>简单数据类型不需要单独分配内存，也不需要计数；</p>
</li>
<li><p>不会再有两次计数的情况。在对象中，只有对象自身存储的计数是有效的；</p>
</li>
<li><p>由于现在计数由数值自身存储，所以也就可以和非 zval 结构的数据共享，比如 zval 和 hashtable key 之间；</p>
</li>
<li><p>间接访问需要的指针数减少了。</p>
</li>
</ol>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h4 id="PHP5中的zval"><a href="#PHP5中的zval" class="headerlink" title="PHP5中的zval"></a>PHP5中的zval</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _zval_struct &#123;</span><br><span class="line">    zvalue_value value; <span class="comment">//16字节</span></span><br><span class="line">    zend_uint refcount__gc; <span class="comment">// 4字节</span></span><br><span class="line">    zend_uchar type; <span class="comment">//1字节</span></span><br><span class="line">    zend_uchar is_ref__gc; <span class="comment">//1字节</span></span><br><span class="line">&#125; zval; <span class="comment">//共占用24字节</span></span><br><span class="line"></span><br><span class="line">typedef union _zvalue_value &#123;</span><br><span class="line">    long lval;                 <span class="comment">// 用于 bool 类型、整型和资源类型 8字节</span></span><br><span class="line">    double dval;               <span class="comment">// 用于浮点类型 8字节</span></span><br><span class="line">    struct &#123;                   <span class="comment">// 用于字符串</span></span><br><span class="line">        char *val;</span><br><span class="line">        int len;</span><br><span class="line">    &#125; str; <span class="comment">// 12字节</span></span><br><span class="line">    HashTable *ht;             <span class="comment">// 用于数组 8字节</span></span><br><span class="line">    zend_object_value obj;     <span class="comment">// 用于对象 //8字节</span></span><br><span class="line">    zend_ast *ast;             <span class="comment">// 用于常量表达式(PHP5.6 才有) 8字节</span></span><br><span class="line">&#125; zvalue_value; <span class="comment">//共占用16字节</span></span><br></pre></td></tr></table></figure>

<h4 id="PHP7中的zval"><a href="#PHP7中的zval" class="headerlink" title="PHP7中的zval"></a>PHP7中的zval</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">struct _zval_struct &#123;</span><br><span class="line">	zend_value        value;			<span class="comment">/* value */</span> <span class="number">8</span>字节</span><br><span class="line">	union &#123;</span><br><span class="line">		struct &#123;</span><br><span class="line">			ZEND_ENDIAN_LOHI_4(</span><br><span class="line">				zend_uchar    type,			<span class="comment">/* active type */</span></span><br><span class="line">				zend_uchar    type_flags,</span><br><span class="line">				zend_uchar    const_flags,</span><br><span class="line">				zend_uchar    reserved)	    <span class="comment">/* call info for EX(This) */</span></span><br><span class="line">		&#125; v;</span><br><span class="line">		uint32_t type_info;</span><br><span class="line">	&#125; u1;<span class="comment">//4字节</span></span><br><span class="line">	union &#123;</span><br><span class="line">		uint32_t     var_flags;</span><br><span class="line">		uint32_t     next;                 <span class="comment">/* hash collision chain */</span></span><br><span class="line">		uint32_t     cache_slot;           <span class="comment">/* literal cache slot */</span></span><br><span class="line">		uint32_t     lineno;               <span class="comment">/* line number (for ast nodes) */</span></span><br><span class="line">		uint32_t     num_args;             <span class="comment">/* arguments number for EX(This) */</span></span><br><span class="line">		uint32_t     fe_pos;               <span class="comment">/* foreach position */</span></span><br><span class="line">		uint32_t     fe_iter_idx;          <span class="comment">/* foreach iterator index */</span></span><br><span class="line">	&#125; u2;<span class="comment">//4字节</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef union _zend_value &#123;</span><br><span class="line">	zend_long         lval;				<span class="comment">/* long value */</span></span><br><span class="line">	double            dval;				<span class="comment">/* double value */</span></span><br><span class="line">	zend_refcounted  *counted;</span><br><span class="line">	zend_string      *str;</span><br><span class="line">	zend_array       *arr;</span><br><span class="line">	zend_object      *obj;</span><br><span class="line">	zend_resource    *res;</span><br><span class="line">	zend_reference   *ref;</span><br><span class="line">	zend_ast_ref     *ast;</span><br><span class="line">	zval             *zv;</span><br><span class="line">	void             *ptr;</span><br><span class="line">	zend_class_entry *ce;</span><br><span class="line">	zend_function    *func;</span><br><span class="line">	struct &#123;</span><br><span class="line">		uint32_t w1;</span><br><span class="line">		uint32_t w2;</span><br><span class="line">	&#125; ww;</span><br><span class="line">&#125; zend_value;</span><br><span class="line"></span><br><span class="line">typedef struct _zend_refcounted_h &#123;</span><br><span class="line">	uint32_t         refcount;			<span class="comment">/* reference counter 32-bit */</span></span><br><span class="line">	union &#123;</span><br><span class="line">		struct &#123;</span><br><span class="line">			ZEND_ENDIAN_LOHI_3(</span><br><span class="line">				zend_uchar    type,</span><br><span class="line">				zend_uchar    flags,    <span class="comment">/* used for strings &amp; objects */</span></span><br><span class="line">				uint16_t      gc_info)  <span class="comment">/* keeps GC root number (or 0) and color */</span></span><br><span class="line">		&#125; v;</span><br><span class="line">		uint32_t type_info;</span><br><span class="line">	&#125; u;</span><br><span class="line">&#125; zend_refcounted_h;</span><br></pre></td></tr></table></figure>

<h2 id="PHP7数组底层实现"><a href="#PHP7数组底层实现" class="headerlink" title="PHP7数组底层实现"></a>PHP7数组底层实现</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ol>
<li><p>PHP 数组是基于哈希表实现的，而与一般哈希表不同的是 PHP 的数组还实现了元素的有序性，就是插入的元素从内存上来看是连续的而不是乱序的，为了实现这个有序性 PHP 采用了「映射表」技术。此外，PHP采用链地址法解决哈希冲突。</p>
</li>
<li><p>映射表和数组元素在同一片连续的内存中，映射表是一个长度与存储元素相同的整型数组，它默认值为 -1 ，有效值为 Bucket 数组的下标。而 HashTable-&gt;arData 指向的是这片内存中 Bucket 数组的首地址。</p>
<p>举个例子 $a[‘key’] 访问数组 $a 中键名为 key 的成员，流程介绍：首先通过 Time 33 算法计算出 key 的哈希值，然后通过散列算法计算出该哈希值对应的映射表下标，因为映射表中保存的值就是 Bucket 数组中的下标值，所以就能获取到 Bucket 数组中对应的元素。</p>
</li>
<li><p>散列算法：nIndex = h | ht-&gt;nTableMask; </p>
<p>将哈希值和 nTableMask 进行或运算即可得出映射表的下标，其中 nTableMask 数值为 nTableSize 的负数。并且由于 nTableSize 的值为 2 的幂次方，所以 h | ht-&gt;nTableMask 的取值范围在 [-nTableSize, -1] 之间，正好在映射表的下标范围内。</p>
</li>
<li><p>散列冲突</p>
<p>不同键名的哈希值通过散列计算得到的「映射表」下标有可能相同，此时便发生了散列冲突。对于这种情况 PHP 使用了「链地址法」解决。</p>
</li>
<li><p>HashTable的初始化</p>
<p>第1步：分配HashTable结构体内存，并初始化各个字段</p>
<p>第2步：分配bucket数组内存，修改一些字段(包括插入元素)</p>
</li>
<li><p>扩容</p>
<ul>
<li>php采用不断动态扩容的方式实现数组存储，新的大小为旧nTableSize值的两倍。<br>此外，删除数组元素时并不会真正触发删除操作，只是做一个标识（将bucket中的val.u1.v.type值设置为IS_UNDEF），删除是在扩容和重建索引时触发。</li>
<li>这里将讨论三个问题：<ul>
<li>什么时候触发扩容以及扩容的实现思路<ul>
<li>向bucket插入元素的时候发现nNumUsed&gt;=nTableSizse时，判断IS_UNDEF 元素占比<br>IS_UNDEF 元素未超过 Bucket 数组的 1/33，则新的bucket大小为原来的两倍</li>
<li>申请新的内存，调用pemalloc函数</li>
<li>更新HashTable的nTableSize和nTableMask值</li>
<li>将arData指向新的bucket首地址</li>
<li>复制原数组的值到新数组并释放原数组内存</li>
<li>重新索引</li>
</ul>
</li>
<li>什么时候触发rehash（rehash就是重新建索引，把IS_UNDEF标志的元素删除掉，然后重建索引表）以及rehash的实现<br>答：当移除有IS_UNDEF标志的元素的时候，就会触发rehash<ul>
<li>具体实现思路：<ul>
<li>重置索引索引数组值为-1</li>
<li>初始化两个bucket类型的指针p和q，循环遍历bucket数组</li>
<li>每次循环，p++，遇到第一个IS_UNDEF是，q=p；继续循环数组</li>
<li>当再一次遇到一个正常数据是，把正常数据拷贝到q指向的位置，q++</li>
<li>知道遍历完数组，更新nNumUsed等</li>
<li>注：rehash不会重新申请内存，而是直接在原bucket上操作。</li>
</ul>
</li>
</ul>
</li>
<li>什么时候把有删除标志的数据真正清理掉<br>答：删除是在扩容和重建索引时触发。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _zend_array HashTable; </span><br><span class="line"></span><br><span class="line">struct _zend_array &#123;</span><br><span class="line">    zend_refcounted_h gc; <span class="comment">//引用计数相关</span></span><br><span class="line">    union &#123;</span><br><span class="line">	    struct &#123;</span><br><span class="line">		    ZEND_ENDIAN_LOHI_4(</span><br><span class="line">		    zend_uchar flags,			<span class="comment">//标志</span></span><br><span class="line">		    zend_ucharn ApplyCount,		<span class="comment">//用于递归遍历计数</span></span><br><span class="line">		    zend_uchar nIteratorsCount,	<span class="comment">//迭代器计数</span></span><br><span class="line">		    zend_uchar consistency)		<span class="comment">//用于调试，只在调试版本中有效</span></span><br><span class="line">    	&#125; v;</span><br><span class="line">   		uint32_t flags;</span><br><span class="line">   	&#125; u;</span><br><span class="line">   	</span><br><span class="line">    uint32_t  nTableMask; <span class="comment">//掩码，用于索引数组，一般为-nTableSize</span></span><br><span class="line">    Bucket   *arData;	  <span class="comment">//指向储存元素的数组第一个Bucket地址（即数组首地址）</span></span><br><span class="line">    uint32_t  nNumUsed;	  <span class="comment">//已使用Bucket数</span></span><br><span class="line">    uint32_t  nNumOfElements; 	<span class="comment">//真正使用的数组空间数，如$ [1]=100，nNumUsed值为2，nNumOfElements值为1</span></span><br><span class="line">    uint32_t  nTableSize; 		<span class="comment">//Bucket的数量，初始值为8，扩容的时候，每次增长为原空间的2倍。改值始终是2的n次方，在64位系统上，最大值是2的31次方</span></span><br><span class="line">    uint32_t  nInternalPointer;	<span class="comment">//HashTable全局默认游标，维护正在遍历的bucket数组中的下标</span></span><br><span class="line">    zend_long nNextFreeElement;	<span class="comment">//下一个可用数字索引，用于直接赋值没有k的数组中k的计算，即$a[]=100这种赋值方式</span></span><br><span class="line">    dtor_func_t   pDestructor;  <span class="comment">//析构函数，当bucket元素被更新或者被删除时，会调用该函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">引用计数结构体：</span><br><span class="line">typedef struct _zend_refcounted_h &#123;</span><br><span class="line">	uint32_t         refcount;			<span class="comment">/* reference counter 32-bit */</span></span><br><span class="line">	union &#123;</span><br><span class="line">		struct &#123;</span><br><span class="line">			ZEND_ENDIAN_LOHI_3(</span><br><span class="line">				zend_uchar    type,</span><br><span class="line">				zend_uchar    flags,    <span class="comment">/* used for strings &amp; objects */</span></span><br><span class="line">				uint16_t      gc_info)  <span class="comment">/* keeps GC root number (or 0) and color */</span></span><br><span class="line">		&#125; v;</span><br><span class="line">		uint32_t type_info;</span><br><span class="line">	&#125; u;</span><br><span class="line">&#125; zend_refcounted_h;</span><br><span class="line"></span><br><span class="line">Bucket结构体：</span><br><span class="line">typedef struct _Bucket &#123;</span><br><span class="line"> 	<span class="comment">// 数组元素的值</span></span><br><span class="line"> 	zval  val;</span><br><span class="line"> 	<span class="comment">// key 通过 Time 33 算法计算得到的哈希值或数字索引</span></span><br><span class="line"> 	zend_ulong h;</span><br><span class="line"> 	<span class="comment">// 字符键名，数字索引则为 NULL</span></span><br><span class="line"> 	zend_string  *key;</span><br><span class="line"> &#125; Bucket;</span><br></pre></td></tr></table></figure>

<h3 id="packed-array"><a href="#packed-array" class="headerlink" title="packed array"></a>packed array</h3><ol>
<li><p>key全是数字</p>
</li>
<li><p>key按照插入顺序排列，插入顺序递增</p>
</li>
<li><p>每个key-value对的存储位置是确定的，都存储在bucket数组的第key个元素上</p>
</li>
<li><p>索引数组的大小不变，初始化HashTable的时候，索引数组的大小为2。对于packed array，不需要用到索引数组，因此该数组的大小一直为2（下面会说到什么是索引数组）</p>
</li>
</ol>
<h3 id="hash-array"><a href="#hash-array" class="headerlink" title="hash array"></a>hash array</h3><ol>
<li><p>对于key是非数字的，必须用hash算法进行计算出来它所在bucket的位置，那么索引数组是必不可少的</p>
</li>
<li><p>key的值较大，或者间隔较大，还是会退化成hash array</p>
</li>
</ol>
<h2 id="PHP的构成"><a href="#PHP的构成" class="headerlink" title="PHP的构成"></a>PHP的构成</h2><h3 id="目录分析"><a href="#目录分析" class="headerlink" title="目录分析"></a>目录分析</h3><ol>
<li><p>sapi目录是PHP的应用接口层。</p>
</li>
<li><p>main为php的主要代码，主要是输入/输出、Web通信、PHP框架的初始化操作等，比如fastcgi协议的解析、扩展的加载、PHP配置的解析等工作都是在这里完成的。</p>
</li>
<li><p>zend目录是PHP解析器的主要实现，即ZendVM，它是PHP语言的核心实现，PHP代码的解释、执行都是由Zend完成的。</p>
</li>
<li><p>ext目录是PHP的扩展目录，比如php的curl扩展，gd库扩展、pdo扩展等都是在这里。 </p>
</li>
<li><p>TSRM目录为线程安全相关的实现。</p>
</li>
</ol>
<p>PHP各组成部分之间关系图： </p>
<h2 id="PHP运行模式"><a href="#PHP运行模式" class="headerlink" title="PHP运行模式"></a>PHP运行模式</h2><ol>
<li><p>cgi（Common Gateway Interface，通用网关接口）模式</p>
</li>
<li><p>fast-cgi模式，即常驻型的cgi</p>
</li>
<li><p>cli（Command Line Interface）命令行运行模式</p>
</li>
<li><p>web模块模式，如apache的mod_php5.so模块</p>
</li>
</ol>
<h3 id="fast-cgi模式"><a href="#fast-cgi模式" class="headerlink" title="fast-cgi模式"></a>fast-cgi模式</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol>
<li><p>Web Server启动时载入FastCGI进程管理器（PHP的FastCGI进程管理器是PHP-FPM）</p>
</li>
<li><p>FastCGI进程管理器自身初始化，启动多个CGI解释器进程 (在任务管理器中可见多个php-cgi.exe)并等待来自Web Server的连接。</p>
</li>
<li><p>当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。</p>
</li>
<li><p>FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器（运行在 WebServer中）的下一个连接。在正常的CGI模式中，php-cgi.exe在此便退出了。</p>
</li>
</ol>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li><p>从稳定性上看, fastcgi是以独立的进程池运行来cgi,单独一个进程死掉,系统可以很轻易的丢弃,然后重新分 配新的进程来运行逻辑。</p>
</li>
<li><p>从安全性上看,Fastcgi支持分布式运算。FastCGI程序也可以和Web服务器分别部署在不同的主机上，它还可以接受来自其他Web服务器的请求。也就是说fastcgi和宿主的server完全独立, fastcgi宕掉不会影响到server。</p>
</li>
<li><p>从性能上看, fastcgi把动态逻辑的处理从server中分离出来, 大负荷的IO处理留给宿主server, 这样宿主server可以一心一意处理IO。</p>
</li>
</ol>
<h2 id="PHP生命周期"><a href="#PHP生命周期" class="headerlink" title="PHP生命周期"></a>PHP生命周期</h2><p>答：PHP的整个生命周期被划分为以下几个阶段：</p>
<ol>
<li><p>模块初始化阶段（module startup）</p>
</li>
<li><p>请求初始化阶段（request startup）</p>
</li>
<li><p>脚本执行阶段（execute sccript）</p>
</li>
<li><p>请求关闭阶段（request shutdown）</p>
</li>
<li><p>模块关闭阶段（module shutdown）</p>
</li>
</ol>
<p>注：根据不同SAPI的实现，各阶段的执行情况会有一些差异，比如命令行模式下，每次执行一个脚本都会完成的经历这些阶段。而FastCgi模式下则在启动时执行一次模块初始化，然后各个请求只经历请求初始化，脚本执行，请求关闭几个阶段，在SAPI关闭时，才经历模块关闭阶段。</p>
<h2 id="PHP内存管理"><a href="#PHP内存管理" class="headerlink" title="PHP内存管理"></a>PHP内存管理</h2><ol>
<li><p>任何内存分配器都需要额外的数据结构来记录内存的分配情况；</p>
</li>
<li><p>内存池是代替直接调用malloc/free、new/delete进行内存管理的常用方法；内存池中空闲内存块组织为链表结构，申请内存只需要查找空闲链表即可，释放内存需要将内存块重新插入空闲链表；</p>
</li>
<li><p>PHP采用预分配内存策略，提前向操作系统分配2M字节大小内存，称为chunk；同时将内存分配请求根据字节大小分为small、huge、large三种；</p>
</li>
<li><p>small内存，采用“分离存储”思想，即将空闲内存块按照字节大小组织为多个空闲链表；</p>
</li>
<li><p>large内存每次会分配连续若干个页，采用最佳适配算法；</p>
</li>
<li><p>huge内存直接使用mmap函数向操作系统申请内存（申请大小是2M字节整数倍）；</p>
</li>
<li><p>chunk中的每个页只会被切割为相同规格的内存块；所以不需要再每个内存块添加头部，只需要记录每个页的属性即可；</p>
</li>
<li><p>如何方便根据地址计算当前内存块属于chunk中的哪一个页？PHP分配的chunk都是2M字节对齐的，任意地址的低21位即是相对chunk首地址，除以页大小则可获得页号；</p>
</li>
</ol>
<h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h3><h4 id="malloc函数"><a href="#malloc函数" class="headerlink" title="malloc函数"></a>malloc函数</h4><ol>
<li><p>malloc（memory allocation，动态内存分配），用于申请一块连续的指定大小的内存块区域</p>
<p>函数原型为void * malloc(unsigned int size)；其作用是在内存的动态存储区中分配一个长度为size的连续空间。返回值为void *类型，成功返回一个指向内存首地址（更确切的说，是指向程序可用的内存首地址，为什么这么说？看下面的图就明白了）的指针，内存创建分配失败则返回空指针NULL。</p>
</li>
<li><p>内存使用完后应该用free()函数将内存块释放。 </p>
<p>free()释放内存的时候，为什么不用传入size？</p>
<p>因为malloc实现的时候，会比传入的size多分配32位即4字节，第3位至31位用来存储块的大小，因此释放内存的时候，通过首地址，往前移动4字节，就可以取到该快的大小值。</p>
</li>
<li><p>如何处理空闲块？</p>
<p>内存分配和释放会导致内存被分割成若干个大小不一样的内存块，其中有些处于已分配状态，有些处于空闲状态，这两个状态就是通过多分配的4字节中的一个比特位来记录的，标志位1表示已分配，0表示空闲。</p>
<p>空闲块可能会被组织成一个链表，遍历空闲块链表就可能查找到合适的内存。</p>
</li>
<li><p>选择合适的内存有很多算法：比如首次适配、最佳适配、最差适配等。</p>
</li>
</ol>
<h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><p>由于频繁malloc分配内存块会导致效率低下（如根据算法找出合适的内存块、调用free等释放内存并且可能会合并空闲块）而且会产生很多内存碎片，也很容易造成内存泄漏。还有可能因申请不到合适的内存导致系统运行不稳定。</p>
<p>因此，内存池就是用来解决上述问题的，由系统提前分配好各种大小的内存，当程序需要申请内存的时候，先去内存池中查找，这样就不用频繁申请和释放内存了。</p>
<h2 id="PHP垃圾回收机制"><a href="#PHP垃圾回收机制" class="headerlink" title="PHP垃圾回收机制"></a>PHP垃圾回收机制</h2><ol>
<li><p>原理</p>
<p>php5和php7的垃圾回收机制都是利用引用计数 </p>
</li>
<li><p>php5和php7不同点</p>
<ul>
<li>PHP5标量数据类型会计数，PHP7标量数据类型不再计数，不需要单独分配内存</li>
</ul>
</li>
</ol>
<ul>
<li>PHP7的zval 需要的内存不再是单独从堆上分配，不再自己存储引用计数。</li>
</ul>
<ul>
<li>PHP7的复杂数据类型（比如数组和对象）的引用计数由其自身来存储。</li>
</ul>
<ol start="3">
<li><p>垃圾回收算法</p>
<ul>
<li><p>在php5.3之前的版本的垃圾回收机制：</p>
<ul>
<li>当对象被引用时，refcount计数器+1</li>
<li>当unset($a)或者出现写时复制等操作后，计数器-1</li>
<li>PHP会根据refcount的值来判断是不是垃圾，如果refcount值减为0，PHP会将该zval容器当做垃圾释放掉，这种回收机制对于环状引用的变量无法回收。</li>
</ul>
</li>
<li><p>因此在php5.3及其之后的版本，垃圾回收的机制为：</p>
<ul>
<li>$a的zval的u1.v.type被标记为0（IS_UNDEF），但是refcount大于0的时候，其指向的内存以及该内存指向的其他内存都可能成为垃圾，垃圾收集器会将这部分可能是垃圾的数据收集到缓冲区。垃圾收集要求数据类型是数组或对象。</li>
<li>当unset($a)操作后，如果refcount大于0，则a变量会被插入到垃圾收集缓冲区中。当缓冲区满了，再收集到新元素就会触发垃圾回收算法：<ul>
<li>对所有垃圾收集器收集到的变量进行遍历，将每个元素中gc_info为紫色（垃圾收集器收集到的变量初始颜色为紫色）的改为灰色，引用计数减1；</li>
<li>扫描所有灰色的元素，如果引用计数任然大于0，说明这个元素还在其他地方使用，那么将其颜色标记为黑色，并将引用计数加1（因为第1步减了1）；如果引用计数为0，则将其标记为白色；</li>
<li>扫描所有元素，将gc_info为黑色的元素从垃圾收集器中移除。然后对白色元素的引用计数加1（因为第1步减了）。将垃圾收集器中的所有元素移动到待释放的列表中（to_free）；</li>
<li>释放to_free列表中的元素。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="PHP错误与异常处理"><a href="#PHP错误与异常处理" class="headerlink" title="PHP错误与异常处理"></a>PHP错误与异常处理</h2><h3 id="PHP中什么是异常"><a href="#PHP中什么是异常" class="headerlink" title="PHP中什么是异常"></a>PHP中什么是异常</h3><p>　　程序在运行中出现不符合预期的情况，允许发生（你也不想让他出现不正常的情况）但他是一种不正常的情况，按照我们的正常逻辑本不该出的错误，但仍然会出现的错误，属于逻辑和业务流程的错误，而不是编译或者语法上的错误。</p>
<h3 id="PHP中什么是错误"><a href="#PHP中什么是错误" class="headerlink" title="PHP中什么是错误"></a>PHP中什么是错误</h3><p>　　属于php脚本自身的问题，大部分情况是由错误的语法，服务器环境导致，使得编译器无法通过检查，甚至无法运行的情况。warning、notice都是错误，只是他们的级别不同而已，并且错误是不能被try-catch捕获的。</p>
<h3 id="PHP异常处理"><a href="#PHP异常处理" class="headerlink" title="PHP异常处理"></a>PHP异常处理</h3><ol>
<li><p>PHP异常处理中的黑科技</p>
<ul>
<li>set_error_handler()</li>
</ul>
</li>
</ol>
<ul>
<li>register_shutdown_function()</li>
</ul>
<ul>
<li>set_exception_handler()</li>
</ul>
<ol start="2">
<li><p>自定义异常处理和异常嵌套</p>
</li>
<li><p>PHP7中的异常处理<br>　　更多的Error变为可捕获的Exception，现在的PHP7实现了一个全局的throwable接口，原来老的Exception和其中一部分Error实现了这个接口(interface)，PHP7中更多的Error变为可捕获的Exception返回给捕捉器，这样其实和前面提到的扩展try-catch影响范围一样，但是如果不捕获则还是按照Error对待.</p>
</li>
</ol>
<h2 id="PHP-FPM及其运行模式"><a href="#PHP-FPM及其运行模式" class="headerlink" title="PHP-FPM及其运行模式"></a>PHP-FPM及其运行模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>PHP-FPM就是PHP中的FastCGI进程管理器。进程包括master进程和worker进程。master进程只有一个，负责管理子进程。worker进程一般会有多个，每个进程中会嵌入一个PHP解析器，处理PHP代码。</p>
<p>如果在Linux上搭建Nginx和PHP环境，则需要安装PHP-FPM模块，让php以FastCGI的方式与nginx进行交互。</p>
<h3 id="三种运行模式"><a href="#三种运行模式" class="headerlink" title="三种运行模式"></a>三种运行模式</h3><ol>
<li><p>pm=static</p>
<p>始终保持固定数量的worker进程数，由pm.max_children决定。</p>
</li>
<li><p>pm=dynamic</p>
<ul>
<li>php-fpm启动时，会初始启动一些worker，初始启动worker数决定于pm.max_children的值。在运行过程中动态调整worker数量，worker的数量受限于pm.max_children配置，同时受限全局配置process.max。 </li>
</ul>
</li>
</ol>
<ul>
<li><p>1秒定时器作用，检查空闲worker数量，按照一定策略动态调整worker数量，增加或减少。增加时，worker最大数量&lt;=max_children· &lt;=全局process.max；减少时，只有idle &gt;pm.max_spare_servers时才会关闭一个空闲worker。 </p>
</li>
<li><p>优点：动态扩容，不浪费系统资源<br>缺点：如果所有worker都在工作，新的请求到来只能等待master在1秒定时器内再新建一个worker，这时可能最长等待1s </p>
</li>
</ul>
<ol start="3">
<li><ul>
<li><p>pm=ondemand<br>php-fpm启动的时候，不会启动任何一个worker，而是按需启动，只有当连接过来的时候才会启动。<br>启动的最大worker数决定于pm.max_children的值，同时受限全局配置process.max。</p>
</li>
<li><p>1秒定时器作用，如果空闲worker时间超过pm.process_idle_timeout的值（默认值为10s），则关闭该worker。这个机制可能会关闭所有的worker。</p>
</li>
<li><p>优点：按流量需求创建，不浪费系统资源<br>缺点：由于php-fpm是短连接的，所以每次请求都会先建立连接，频繁的创建worker会浪费系统开销。所以，在大流量的系统上，master进程会变得繁忙，占用系统cpu资源，不适合大流量环境的部署。</p>
</li>
</ul>
</li>
</ol>
<h3 id="PHP执行机制"><a href="#PHP执行机制" class="headerlink" title="PHP执行机制"></a>PHP执行机制</h3><p>PHP执行过程会经过如下4个步骤： </p>
<img src="/2020/05/23/01%20PHP/PHP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05/23/01%20PHP/PHP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E7%89%871.png" class title="PHP代码执行流程">

<ol>
<li><p>Scanning(Lexing) 对PHP源码进行词法分析，将源代码切割为多个字符串单元，分割后的字符串称为Token</p>
</li>
<li><p>Parsing 将Token进行语法分析，转换成抽象语法树（AST）</p>
</li>
<li><p>Compilation AST经过编译器编译为机器指令（PHP定义的一组指令表示，每个指令对应响应的处理函数），这些机器指令称为Opcodes。（这里说的编译器不同与编译型语言中的编译器，AST经过编译器被编译成能被解释执行的指令，而不是汇编代码）</p>
</li>
<li><p>Execution zend虚拟机依次执行Opcodes，这个执行过程就是找到指令对于的处理函数，执行其中的代码 </p>
</li>
</ol>
<p>注：现在的PHP可以将Opcodes缓存住，从而不必每次都执行前3步，除非PHP检测到代码发生了改变。从而很大程度上提高了PHP的执行效率。</p>

</div>


    <div class="post-guide">
        <div class="item left">
            
        </div>
        <div class="item right">
            
        </div>
    </div>



	<div id="vcomments"></div>


<script>
	
		// 评论
		new Valine({
			av: AV,
			el: '#vcomments',
			notify: false,
			verify: false,
			path: window.location.pathname,
			appId: '',
			appKey: '',
			placeholder: '请输入评论',
			avatar: 'retro',
			recordIP: false
		})
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	<a href="/">dongysh</a> 
	
	
		|
		<span id="busuanzi_container_site_pv">
			pv
			<span id="busuanzi_value_site_pv"></span>
		</span>
		|
		<span id="busuanzi_container_site_uv"> 
			uv
			<span id="busuanzi_value_site_uv"></span>
		</span>
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	by <a href="//github.com/wujun234" target="_blank">WuJun</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>